import express from "express";
import { db } from "../db/index.js";
import { student_profile, user } from "../db/schema/index.js";
import { requireAuth } from "../middleware/authmiddleware.js";
import { eq, count, isNotNull } from "drizzle-orm";
import multer from "multer";
import csvParser from "csv-parser";
import XLSX from "xlsx";
import bcrypt from "bcryptjs";
import { Readable } from "stream";

const router = express.Router();

// Configure multer for file uploads
const storage = multer.memoryStorage();
const upload = multer({
    storage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
    fileFilter: (req, file, cb) => {
        const allowedTypes = [
            "text/csv",
            "application/vnd.ms-excel",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        ];
        if (allowedTypes.includes(file.mimetype)) cb(null, true);
        else cb(new Error("Invalid file type. Only CSV and Excel files are allowed."));
    },
});

// âœ… Google Form Template Configuration
const GOOGLE_FORM_TEMPLATE_ID = process.env.GOOGLE_FORM_TEMPLATE_ID || null;
console.log("âœ… Loaded GOOGLE_FORM_TEMPLATE_ID:", GOOGLE_FORM_TEMPLATE_ID);

// ðŸ”— Generate Google Form Link
router.post("/generate-form", requireAuth, async (req, res) => {
    try {
        if (req.user.role !== "placement") {
            return res
                .status(403)
                .json({ ok: false, error: "Only placement cell can generate forms" });
        }

        if (!GOOGLE_FORM_TEMPLATE_ID) {
            return res.status(400).json({
                ok: false,
                error: "Google Form Template ID is missing. Please set GOOGLE_FORM_TEMPLATE_ID in your .env",
            });
        }

        const formUrl = `https://docs.google.com/forms/d/${GOOGLE_FORM_TEMPLATE_ID}/edit`;

        console.log(`ðŸ“„ Form generated by user ${req.user.id} at ${new Date().toISOString()}`);

        res.json({
            ok: true,
            formUrl,
            message: "Google Form generated successfully",
            instructions: [
                "Copy the form URL",
                "Share it with students via WhatsApp",
                "After students submit, download responses as Excel/CSV from Google Forms",
                "Upload the file using the bulk upload feature",
            ],
        });
    } catch (error) {
        console.error("Error generating form:", error);
        res.status(500).json({ ok: false, error: String(error) });
    }
});

// CSV Parsing
const parseCSV = (buffer) =>
    new Promise((resolve, reject) => {
        const results = [];
        const stream = Readable.from(buffer.toString());
        stream
            .pipe(csvParser())
            .on("data", (data) => results.push(data))
            .on("end", () => resolve(results))
            .on("error", (error) => reject(error));
    });

// Excel Parsing
const parseExcel = (buffer) => {
    try {
        const workbook = XLSX.read(buffer, { type: "buffer" });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        return XLSX.utils.sheet_to_json(worksheet);
    } catch (error) {
        throw new Error("Failed to parse Excel file");
    }
};

// Validate data
const validateStudentData = (data) => {
    const errors = [];
    if (!data["Full Name"] && !data["full_name"]) errors.push("Full Name is required");
    if (!data["Email"] && !data["email"]) errors.push("Email is required");
    else {
        const email = data["Email"] || data["email"];
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) errors.push("Invalid email format");
    }
    return { isValid: errors.length === 0, errors };
};

// Normalize data
const normalizeData = (data) => ({
    full_name: data["Full Name"] || data["full_name"] || data["Name"] || "",
    email: data["Email"] || data["email"] || "",
    roll_number: data["Roll Number"] || data["roll_number"] || null,
    student_id: data["Student ID"] || data["student_id"] || null,
    branch: data["Branch"] || data["branch"] || null,
    current_semester: data["Current Semester"] || data["current_semester"] || null,
    cgpa: data["CGPA"] || data["cgpa"] || null,
    tenth_score: data["10th Score"] || data["tenth_score"] || null,
    twelfth_score: data["12th Score"] || data["twelfth_score"] || null,
    contact_number: data["Contact Number"] || data["contact_number"] || null,
    date_of_birth: data["Date of Birth"] || data["date_of_birth"] || null,
    gender: data["Gender"] || data["gender"] || null,
    linkedin: data["LinkedIn"] || data["linkedin"] || null,
    skills: data["Skills"] || data["skills"] || null,
});

// ðŸ§¾ Bulk Upload Students
router.post("/bulk-upload", requireAuth, upload.single("file"), async (req, res) => {
    try {
        if (req.user.role !== "placement") {
            return res
                .status(403)
                .json({ ok: false, error: "Only placement cell can upload student data" });
        }

        if (!req.file) return res.status(400).json({ ok: false, error: "No file uploaded" });

        const parsedData =
            req.file.mimetype === "text/csv"
                ? await parseCSV(req.file.buffer)
                : parseExcel(req.file.buffer);

        if (!parsedData.length)
            return res.status(400).json({ ok: false, error: "No data found in file" });

        console.log(`Processing ${parsedData.length} student records...`);

        const results = { total: parsedData.length, successful: 0, failed: 0, errors: [] };

        for (let i = 0; i < parsedData.length; i++) {
            try {
                const raw = parsedData[i];
                const studentData = normalizeData(raw);
                const validation = validateStudentData(raw);
                if (!validation.isValid) {
                    results.failed++;
                    results.errors.push({ row: i + 2, errors: validation.errors, data: studentData });
                    continue;
                }

                const existingUser = await db
                    .select()
                    .from(user)
                    .where(eq(user.email, studentData.email))
                    .limit(1);

                let userId;
                if (existingUser.length === 0) {
                    const defaultPassword = await bcrypt.hash("student123", 10);
                    const newUser = await db
                        .insert(user)
                        .values({ email: studentData.email, password: defaultPassword, role: "student" })
                        .returning();
                    userId = newUser[0].id;
                } else userId = existingUser[0].id;

                const profileData = {
                    user_id: userId,
                    ...studentData,
                    date_of_birth: studentData.date_of_birth ? new Date(studentData.date_of_birth) : null,
                };

                Object.keys(profileData).forEach(
                    (key) => !profileData[key] && delete profileData[key]
                );

                const existingProfile = await db
                    .select()
                    .from(student_profile)
                    .where(eq(student_profile.user_id, userId))
                    .limit(1);

                if (existingProfile.length)
                    await db
                        .update(student_profile)
                        .set({ ...profileData, updated_at: new Date() })
                        .where(eq(student_profile.user_id, userId));
                else await db.insert(student_profile).values(profileData);

                results.successful++;
            } catch (error) {
                console.error(`Error processing row ${i + 2}:`, error);
                results.failed++;
                results.errors.push({ row: i + 2, errors: [error.message], data: parsedData[i] });
            }
        }

        res.json({ ok: true, message: "Bulk upload completed", results });
    } catch (error) {
        console.error("Error in bulk upload:", error);
        res.status(500).json({ ok: false, error: error.message });
    }
});

// ðŸ“¥ Download CSV Template
router.get("/download-template", requireAuth, (req, res) => {
    try {
        if (req.user.role !== "placement") {
            return res
                .status(403)
                .json({ ok: false, error: "Only placement cell can download template" });
        }

        const headers = [
            "Full Name",
            "Email",
            "Roll Number",
            "Student ID",
            "Branch",
            "Current Semester",
            "CGPA",
            "10th Score",
            "12th Score",
            "Contact Number",
            "Date of Birth",
            "Gender",
            "LinkedIn",
            "Skills",
        ];

        const sampleRow = [
            "John Doe",
            "john.doe@example.com",
            "CS001",
            "STU001",
            "Computer Science",
            "6",
            "8.5",
            "95",
            "92",
            "9876543210",
            "2003-01-15",
            "Male",
            "https://linkedin.com/in/johndoe",
            "JavaScript, React, Node.js",
        ];

        const csvContent = [headers.join(","), sampleRow.join(",")].join("\n");

        res.setHeader("Content-Type", "text/csv");
        res.setHeader(
            "Content-Disposition",
            "attachment; filename=student_details_template.csv"
        );
        res.send(csvContent);
    } catch (error) {
        console.error("Error downloading template:", error);
        res.status(500).json({ ok: false, error: String(error) });
    }
});

// ðŸ†• Download Student Login Details (Excel)
router.get("/download-login-details", requireAuth, async (req, res) => {
    try {
        if (req.user.role !== "placement") {
            return res
                .status(403)
                .json({ ok: false, error: "Only placement cell can download login details" });
        }

        const defaultPassword = "student123";
        const hashedPassword = await bcrypt.hash(defaultPassword, 10);

        // Fetch all students with their user accounts and user IDs
        const studentsData = await db
            .select({
                full_name: student_profile.full_name,
                email: user.email,
                user_id: user.id,
            })
            .from(student_profile)
            .leftJoin(user, eq(student_profile.user_id, user.id))
            .where(eq(user.role, "student"));

        // Reset all student passwords to the default password
        for (const student of studentsData) {
            if (student.user_id) {
                await db
                    .update(user)
                    .set({ password: hashedPassword })
                    .where(eq(user.id, student.user_id));
            }
        }

        // Prepare data for Excel
        const excelData = studentsData.map(student => ({
            "Student Name": student.full_name || "N/A",
            "Email ID": student.email || "N/A",
            "Password": defaultPassword,
        }));

        // Create workbook and worksheet
        const workbook = XLSX.utils.book_new();
        const worksheet = XLSX.utils.json_to_sheet(excelData);

        // Set column widths
        worksheet['!cols'] = [
            { wch: 30 }, // Student Name
            { wch: 35 }, // Email ID
            { wch: 15 }, // Password
        ];

        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(workbook, worksheet, "Student Login Details");

        // Generate buffer
        const excelBuffer = XLSX.write(workbook, { type: "buffer", bookType: "xlsx" });

        // Set response headers
        res.setHeader(
            "Content-Type",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        );
        res.setHeader(
            "Content-Disposition",
            `attachment; filename=student_login_details_${new Date().toISOString().split('T')[0]}.xlsx`
        );

        // Send the file
        res.send(excelBuffer);

        console.log(`âœ… Reset passwords for ${studentsData.length} students and downloaded login details`);
    } catch (error) {
        console.error("Error downloading login details:", error);
        res.status(500).json({ ok: false, error: String(error) });
    }
});

// ðŸ‘¥ Get Students List
router.get("/students", requireAuth, async (req, res) => {
    try {
        if (req.user.role !== "placement") {
            return res
                .status(403)
                .json({ ok: false, error: "Only placement cell can view students" });
        }

        const students = await db
            .select({
                id: student_profile.id,
                full_name: student_profile.full_name,
                email: user.email,
                roll_number: student_profile.roll_number,
                branch: student_profile.branch,
                current_semester: student_profile.current_semester,
                cgpa: student_profile.cgpa,
                contact_number: student_profile.contact_number,
            })
            .from(student_profile)
            .leftJoin(user, eq(student_profile.user_id, user.id))
            .limit(100);

        res.json({ ok: true, students });
    } catch (error) {
        console.error("Error fetching students:", error);
        res.status(500).json({ ok: false, error: String(error) });
    }
});

// ðŸ‘¤ Get Single Student Details
router.get("/students/:id", requireAuth, async (req, res) => {
    try {
        if (req.user.role !== "placement") {
            return res
                .status(403)
                .json({ ok: false, error: "Only placement cell can view student details" });
        }

        const studentId = req.params.id;
        const student = await db
            .select({
                id: student_profile.id,
                user_id: student_profile.user_id,
                full_name: student_profile.full_name,
                email: user.email,
                roll_number: student_profile.roll_number,
                student_id: student_profile.student_id,
                branch: student_profile.branch,
                current_semester: student_profile.current_semester,
                cgpa: student_profile.cgpa,
                tenth_score: student_profile.tenth_score,
                twelfth_score: student_profile.twelfth_score,
                contact_number: student_profile.contact_number,
                date_of_birth: student_profile.date_of_birth,
                gender: student_profile.gender,
                linkedin: student_profile.linkedin,
                skills: student_profile.skills,
            })
            .from(student_profile)
            .leftJoin(user, eq(student_profile.user_id, user.id))
            .where(eq(student_profile.id, studentId))
            .limit(1);

        if (student.length === 0) {
            return res.status(404).json({ ok: false, error: "Student not found" });
        }

        res.json({ ok: true, student: student[0] });
    } catch (error) {
        console.error("Error fetching student details:", error);
        res.status(500).json({ ok: false, error: String(error) });
    }
});

// âœï¸ Update Student Details
router.put("/students/:id", requireAuth, async (req, res) => {
    try {
        if (req.user.role !== "placement") {
            return res
                .status(403)
                .json({ ok: false, error: "Only placement cell can update student details" });
        }

        const studentId = req.params.id;
        const updateData = req.body;

        // Validate email if provided
        if (updateData.email) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(updateData.email)) {
                return res.status(400).json({ ok: false, error: "Invalid email format" });
            }
        }

        // Get current student data to find user_id
        const currentStudent = await db
            .select({ user_id: student_profile.user_id })
            .from(student_profile)
            .where(eq(student_profile.id, studentId))
            .limit(1);

        if (currentStudent.length === 0) {
            return res.status(404).json({ ok: false, error: "Student not found" });
        }

        const userId = currentStudent[0].user_id;

        // Prepare update objects
        const profileUpdate = {};
        const userUpdate = {};

        // Separate user and profile fields
        const userFields = ['email'];
        const profileFields = [
            'full_name', 'roll_number', 'student_id', 'branch', 'current_semester',
            'cgpa', 'tenth_score', 'twelfth_score', 'contact_number', 'date_of_birth',
            'gender', 'linkedin', 'skills'
        ];

        Object.keys(updateData).forEach(key => {
            if (userFields.includes(key)) {
                userUpdate[key] = updateData[key];
            } else if (profileFields.includes(key)) {
                if (key === 'date_of_birth' && updateData[key]) {
                    profileUpdate[key] = new Date(updateData[key]);
                } else {
                    profileUpdate[key] = updateData[key];
                }
            }
        });

        // Update user table if email changed
        if (Object.keys(userUpdate).length > 0) {
            await db.update(user).set(userUpdate).where(eq(user.id, userId));
        }

        // Update student_profile table
        if (Object.keys(profileUpdate).length > 0) {
            profileUpdate.updated_at = new Date();
            await db.update(student_profile).set(profileUpdate).where(eq(student_profile.id, studentId));
        }

        res.json({ ok: true, message: "Student details updated successfully" });
    } catch (error) {
        console.error("Error updating student:", error);
        res.status(500).json({ ok: false, error: String(error) });
    }
});

// ðŸ“Š Get Stats
router.get("/stats", requireAuth, async (req, res) => {
    try {
        if (req.user.role !== "placement") {
            return res
                .status(403)
                .json({ ok: false, error: "Only placement cell can view stats" });
        }

        const totalStudents = await db.select({ count: count() }).from(student_profile);
        const activeStudents = await db
            .select({ count: count() })
            .from(student_profile)
            .where(isNotNull(student_profile.full_name));

        res.json({
            ok: true,
            stats: {
                total: parseInt(totalStudents[0]?.count || 0),
                active: parseInt(activeStudents[0]?.count || 0),
            },
        });
    } catch (error) {
        console.error("Error fetching stats:", error);
        res.status(500).json({ ok: false, error: String(error) });
    }
});

export default router;